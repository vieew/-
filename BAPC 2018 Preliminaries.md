# 题解整理



## A题

#### 题目：

有一种建筑结构（看作二维数组），建筑（二维数组）的最后一行与地面相接触，需要求出该建筑的重心的x坐标来判断该建筑是向右偏，向左偏，还是平衡的状态。

#### 解题思路：

首先要利用(x1+x2+...+xn)/n来求出建筑重心的x坐标（即二维数组的列）。因此遍历二维数组，**统计不是'.'符号的个数及其x（列）坐标的总和**。计算重心坐标的时候需要**四舍五入上取整**(一个点相当于一个小区间[i,i+1])，用于后续判断重心的x坐标与左右边界的关系。之后再次遍历二维数组求出左边界l和右边界r，与重心的x坐标进行比较，输出结果即可。

#### 我的想法

首先我一直没看懂题目，最开始以为是每一层的重心和最下面一层去比较，后来又以为是每一层和下面的一层比较。去问了别人才知道是求出整个的重心再和最下面一层比较。

知道了题目意思，我写了找到每一层最左边的'.'和最右边的'.'，以求出重心。这样照理来说是没错的，但是应该是**会出现中间为'.'的情况**，那就必须把每个坐标的值加起来再去除以总数了。

最后还要注意四舍五入向上取整，用

```C++
	int x = y + 0.5;
```

来向上取整。

四舍五入的原因是，一个点其实是一个区间[i,i+1]，加的时候算的是i，在计算的时候重心是个浮点数，要根据值四舍五入后得到整数。(如果用int/int得到的是向下取整的)



## B题

#### 题意：

蜜蜂可以在某个格子放蜂蜜，蜂蜜会自己向相邻的格子流，问最少需要放几次能达到需要的数量的格子。

#### 思路：

看图可以发现，对于奇数行来说，相邻的格子里面，右上角和右下角的是同一列的，即[x±1,y]，但是**左上角和左下角**的是前一列的,即**[x±1,y-1]**，对于偶数行来说，相邻的格子里面**右上角和右下角**的格子是下一列的，即**[x±1,y+1]**。所以在原来的4个方向的基础上增加到6个方向。

![fig1.jpg](https://res.jisuanke.com/img/upload/a70888e6af40795b45ed93488623be93deab4675.jpg)

![image-20200416141046345](C:\Users\Nan\AppData\Roaming\Typora\typora-user-images\image-20200416141046345.png)

然后用DFS或者BFS求出每一个块有几个格子，用贪心找最大的块就可以。

**注意：如果需要的格子为0，输出0**



## C题

#### 题意

给出n个点和m条线，问能不能把m条线全部连在点上。

#### 样例

5 4

0 2 3 5 8



#### 思路

n个点有n*(n-1)/2个距离，如果直接全求出来肯定会超时。

可以知道相邻的两个点之间的距离肯定是最小的，那么就先把这些距离 x[i] - x[i-1] 以及两端的点的位置 x[i-1] 和 x[i] 组合起来放进优先队列。

再把每次出队一个变量，看是否小于当前最短的那个线，小于的话，就说明可以连接。如果不小于，就可以直接退出循环了。

设当前的点左边为 l，右边为 r，则每次进队的时候是进 x[l] 和 x[r+1] ，就可以把每个点距离其他点的距离都算出来。因为越到后面越大，很有可能不需要全都算完，所以这样算比较方便也不会超时。

**(可以看看代码里面的优先队列的代码和结构体重载运算符)**





## I题

#### 题意：

给出一个字符串，可以截成很多段，一段一段对应地对称，求出这一个字符串能分解的最多的段数。

如132594414896459441321，分解成  **1 32 59411 4 896 4 59411 32 1**

#### 思路：

可以看出直接贪心，找到最短的符合的就直接计算。

首先就想到可以直接设两个指针 l 和 r 指向头和尾，然后设一个 x 为这一段的长度，比较一下s[l,l+x]和s[r-x,r]。

但是比较的时候时间复杂度就比较高了，直接暴力比较复杂度是n*n，用string来比较也会因为串的长度过长而提高复杂度。所以需要用到字符串哈希。

**对于这道题，用131进行哈希。**

**设 l 和 r 分别指向要取的串的末尾和开头，start指向 l 所在串的开头，end指向 r 所在串的末尾。即前面的一段是s[start, l]，后面的一段是s[r, end]，计算哈希数值然后进行比较。相等的话，ans += 2，start = l + 1，end = r - 1。**

最后的特判，如果串长度为奇数，表明最中间的串肯定是没有对应的对称串，所以在上一步里面没有计算进去。

如果串长度为偶数，且被分成了奇数份(如121212)，会造成退出循环的时候start <= end，此时也要把最中间的算进去。





## J题

#### 题意

给出n个字符串，每个长k，任意两个字符串之间的边的值的计算是，两个字符串的同一个位置的字母如果不同就+1，求出连接所有点的最小的值。

是一道最小生成树问题，根据题意画出图，可以看出应该选择红黄蓝三条边。然后套模板

![J题](E:\大二下\ACM\04.13 - 04.19\04.15 计蒜客 周赛\J题.png)





#### 并查集

最开始：

|  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: |
|  1   |  2   |  3   |  4   |

找到第一条边(红色边)

|  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: |
|  1   |  1   |  3   |  4   |

找到第二条边(蓝色边)

|  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: |
|  1   |  1   |  3   |  3   |

找到第三条边(黄色边)

|  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: |
|  1   |  1   |  1   |  3   |

后面就没有变化了